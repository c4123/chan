<!-- This comment will put IE 6, 7 and 8 in quirks mode -->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>chan: Main Page</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javaScript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body onload='searchBox.OnSelectItem(0);'>
<!-- Generated by Doxygen 1.6.3 -->
<script type="text/javascript"><!--
var searchBox = new SearchBox("searchBox", "search",false,'Search');
--></script>
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li class="current"><a href="index.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <img id="MSearchSelect" src="search/search.png"
             onmouseover="return searchBox.OnSearchSelectShow()"
             onmouseout="return searchBox.OnSearchSelectHide()"
             alt=""/>
        <input type="text" id="MSearchField" value="Search" accesskey="S"
             onfocus="searchBox.OnSearchFieldFocus(true)" 
             onblur="searchBox.OnSearchFieldFocus(false)" 
             onkeyup="searchBox.OnSearchFieldChange(event)"/>
        <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
        </div>
      </li>
    </ul>
  </div>
</div>
<div class="contents">
<h1>chan Documentation</h1><h3 class="version">chan 0.0.1a </h3><p><a class="el" href="chan_8h.html#a7b5f296618b811f11b7fefa902ca400a">Chan</a> is a cross-platfrom zero-copy multi-producer mutli-consumer asynchronous FIFO queue for passing messages between threads. Reading and writing to the queue are both performed via <a class="el" href="chan_8c.html#acc5d7503399436e951fac0923371990e" title="Push or pop next item. May block the calling thread.">Chan_Next()</a>. Whether a "read" or a "write" happens depends on the <em>mode</em> passed to <a class="el" href="chan_8c.html#a9be0713b51726eb1708bc00eb334edf4" title="does ref counting and access type">Chan_Open()</a>, which returns a reference-counted "reader" or "writer" reference to the queue.</p>
<p>Note that "opening" a channel is different than "allocating" it. A <a class="el" href="chan_8h.html#a7b5f296618b811f11b7fefa902ca400a">Chan</a> is typically allocated once, but may be opened and closed many times. <a class="el" href="chan_8c.html#a32df9018f0be4ff3a9839ba338c089b1">Chan_Alloc()</a> initializes and reserves memory for the queue. Internally, <a class="el" href="chan_8c.html#a9be0713b51726eb1708bc00eb334edf4" title="does ref counting and access type">Chan_Open()</a> does little more than some bookkeeping.</p>
<p><a class="el" href="chan_8h.html#a7b5f296618b811f11b7fefa902ca400a">Chan</a> was designed so that <a class="el" href="chan_8c.html#acc5d7503399436e951fac0923371990e" title="Push or pop next item. May block the calling thread.">Chan_Next()</a> operations block the calling thread under some circumstances. See <a class="el" href="index.html#next">Next Functions</a> for details. With proper use, this design garauntees that certain networks of threads (namely, directed acyclic graphs) connected by <a class="el" href="chan_8h.html#a7b5f296618b811f11b7fefa902ca400a">Chan</a> instances will deliver every message emited from a producer to a consumer in that network. Once the network is assembled, messages will be recieved in topological order.</p>
<h2><a class="anchor" id="ex">
Example producer/consumer</a></h2>
<p>An example producer thread might look something like this: </p>
<div class="fragment"><pre class="fragment">    <span class="keywordtype">void</span> <a class="code" href="cv2_8c.html#a2e4a7646c5d2cd9d818d93cd8ab12b91">producer</a>(<a class="code" href="chan_8h.html#a7b5f296618b811f11b7fefa902ca400a">Chan</a> *q)
    { <span class="keywordtype">void</span>  *data = <a class="code" href="chan_8c.html#a54ece3f41ff61f2b2f5e563028b44d73">Chan_Token_Buffer_Alloc</a>(q);
      <span class="keywordtype">size_t</span> nbytes;
      <a class="code" href="chan_8h.html#a7b5f296618b811f11b7fefa902ca400a">Chan</a>  *output = <a class="code" href="chan_8c.html#a9be0713b51726eb1708bc00eb334edf4" title="does ref counting and access type">Chan_Open</a>(q,<a class="code" href="chan_8h.html#a18e6baae740254b6b2ce122063dbedc0a46dfc5bac382c0640d5cf5c5ef64d9a2">CHAN_WRITE</a>);
      <span class="keywordflow">while</span>( getdata(&amp;data,&amp;nbytes) )
        <span class="keywordflow">if</span>( <a class="code" href="chan_8h.html#a4c6a1ee80ee305fa573e7fb4766422f5">CHAN_FAILURE</a>( <a class="code" href="chan_8c.html#acc5d7503399436e951fac0923371990e" title="Push or pop next item. May block the calling thread.">Chan_Next</a>(output,&amp;data,&amp;nbytes)))
          <span class="keywordflow">break</span>;
      <a class="code" href="chan_8c.html#a48885b96fe1ab07baa07c665b887e2b1" title="does ref counting">Chan_Close</a>(output);
      <a class="code" href="chan_8c.html#a9ff0178bfa0e25b95002b844d6794ce2">Chan_Token_Buffer_Free</a>(data);
    }
</pre></div><p>An example consumer might look something like this: </p>
<div class="fragment"><pre class="fragment">    <span class="keywordtype">void</span> <a class="code" href="cv2_8c.html#aed175df9d3823d3c4cf5c8f9fde3c8b4">consumer</a>(<a class="code" href="chan_8h.html#a7b5f296618b811f11b7fefa902ca400a">Chan</a> *q)
    { <span class="keywordtype">void</span> *data = <a class="code" href="chan_8c.html#a54ece3f41ff61f2b2f5e563028b44d73">Chan_Token_Buffer_Alloc</a>(q);
      <span class="keywordtype">size_t</span> nbytes;
      <a class="code" href="chan_8h.html#a7b5f296618b811f11b7fefa902ca400a">Chan</a> *input = <a class="code" href="chan_8c.html#a9be0713b51726eb1708bc00eb334edf4" title="does ref counting and access type">Chan_Open</a>(q,<a class="code" href="chan_8h.html#a18e6baae740254b6b2ce122063dbedc0a1ac720d1b0d773df451656fbf54c57c4">CHAN_READ</a>);
      <span class="keywordflow">while</span>( <a class="code" href="chan_8h.html#a10eb0f442b8b926dced49207086c0213">CHAN_SUCCESS</a>( <a class="code" href="chan_8c.html#acc5d7503399436e951fac0923371990e" title="Push or pop next item. May block the calling thread.">Chan_Next</a>(input,&amp;data,&amp;nbytes)))
        dosomething(data,nbytes);
      <a class="code" href="chan_8c.html#a48885b96fe1ab07baa07c665b887e2b1" title="does ref counting">Chan_Close</a>(input);
      <a class="code" href="chan_8c.html#a9ff0178bfa0e25b95002b844d6794ce2">Chan_Token_Buffer_Free</a>(data);
    }
</pre></div><p>Both the <code><a class="el" href="cv2_8c.html#a2e4a7646c5d2cd9d818d93cd8ab12b91">producer()</a></code> and <code><a class="el" href="cv2_8c.html#aed175df9d3823d3c4cf5c8f9fde3c8b4">consumer()</a></code> take a <a class="el" href="chan_8h.html#a7b5f296618b811f11b7fefa902ca400a">Chan</a>*, <code>q</code>, as input. This is the communication channel that will link the two threads. Both functions start by using <a class="el" href="chan_8c.html#a54ece3f41ff61f2b2f5e563028b44d73">Chan_Token_Buffer_Alloc()</a> to allocate space for the first message. It isn't neccessary to call this in <code><a class="el" href="cv2_8c.html#a2e4a7646c5d2cd9d818d93cd8ab12b91">producer()</a></code>, but it is a recommended pattern. See <a class="el" href="index.html#mem">Memory management</a> for details.</p>
<p>The <code><a class="el" href="cv2_8c.html#a2e4a7646c5d2cd9d818d93cd8ab12b91">producer()</a></code> opens a <a class="el" href="chan_8h.html#a18e6baae740254b6b2ce122063dbedc0a46dfc5bac382c0640d5cf5c5ef64d9a2">CHAN_WRITE</a> reference to <code>q</code>, and generates data using the mysterious <code>getdata()</code> procedure that fills the <code>data</code> buffer with something interesting. It is ok if <code>getdata()</code> changes or reallocates the <code>data</code> pointer.</p>
<p>The <a class="el" href="cv2_8c.html#a2e4a7646c5d2cd9d818d93cd8ab12b91">producer()</a> then pushes <code>data</code> onto the queue with <a class="el" href="chan_8c.html#acc5d7503399436e951fac0923371990e" title="Push or pop next item. May block the calling thread.">Chan_Next()</a>. Pushing just swaps the address pointed to by <code>data</code> with the address of an unused buffer that the queue has been keeping track of, so pushing is fast. In the example, if the push fails, the <code><a class="el" href="cv2_8c.html#a2e4a7646c5d2cd9d818d93cd8ab12b91">producer()</a></code> will clean up and terminate. Techinically, the push can only fail here if something goes wrong with the under-the-hood synchronization.</p>
<p>The <a class="el" href="cv2_8c.html#aed175df9d3823d3c4cf5c8f9fde3c8b4">consumer()</a> thread will wait at the first <a class="el" href="chan_8c.html#acc5d7503399436e951fac0923371990e" title="Push or pop next item. May block the calling thread.">Chan_Next()</a> call till a message is available. The order in which the produce() or <a class="el" href="cv2_8c.html#aed175df9d3823d3c4cf5c8f9fde3c8b4">consumer()</a> threads are started does not matter. Popping just swaps the address pointed to by <code>data</code> with the last message on the queue, so popping is fast. This behavior is the reason behind allocating the <code>data</code> buffer with <a class="el" href="chan_8c.html#a54ece3f41ff61f2b2f5e563028b44d73">Chan_Token_Buffer_Alloc()</a>; the queue will hold on to that buffer and recycle it later.</p>
<p>Now suppose we have a different scenario. The <code>consumer</code> thread starts, calls <a class="el" href="chan_8c.html#acc5d7503399436e951fac0923371990e" title="Push or pop next item. May block the calling thread.">Chan_Next()</a> and begins waiting for data, but <code><a class="el" href="cv2_8c.html#a2e4a7646c5d2cd9d818d93cd8ab12b91">producer()</a></code> never produces any data; <code>getdata()</code> returns false. When the <code><a class="el" href="cv2_8c.html#a2e4a7646c5d2cd9d818d93cd8ab12b91">producer()</a></code> calls <a class="el" href="chan_8c.html#a48885b96fe1ab07baa07c665b887e2b1" title="does ref counting">Chan_Close()</a>, this releases the last writer reference to the queue and notifies waiting threads. The <code><a class="el" href="cv2_8c.html#aed175df9d3823d3c4cf5c8f9fde3c8b4">consumer()</a>'s</code> call to <a class="el" href="chan_8c.html#acc5d7503399436e951fac0923371990e" title="Push or pop next item. May block the calling thread.">Chan_Next()</a> will return false, since no data was available, and the consumer can get on with it's life.</p>
<h2><a class="anchor" id="next">
Next Functions</a></h2>
<p>These require a mode to be set via <a class="el" href="chan_8c.html#a9be0713b51726eb1708bc00eb334edf4" title="does ref counting and access type">Chan_Open()</a>. For <a class="el" href="chan_8h.html#a7b5f296618b811f11b7fefa902ca400a">Chan</a>'s open in read mode, does a pop. Reads will fail if there are no writers for the <a class="el" href="chan_8h.html#a7b5f296618b811f11b7fefa902ca400a">Chan</a> and the <a class="el" href="chan_8h.html#a7b5f296618b811f11b7fefa902ca400a">Chan</a> is empty and a writer was at some point opened for the <a class="el" href="chan_8h.html#a7b5f296618b811f11b7fefa902ca400a">Chan</a>. Otherwise, when the <a class="el" href="chan_8h.html#a7b5f296618b811f11b7fefa902ca400a">Chan</a> is empty, reads will block. For <a class="el" href="chan_8h.html#a7b5f296618b811f11b7fefa902ca400a">Chan</a>'s open in write mode, does a push. Writes will block when the <a class="el" href="chan_8h.html#a7b5f296618b811f11b7fefa902ca400a">Chan</a> is full.</p>
<div class="fragment"><pre class="fragment">
      *    Overflow                       Underflow
    =====  ============================   ===================
    -      Waits or expands.              Fails if no sources, otherwise waits.
    Copy   Waits or expands.              Fails if no sources, otherwise waits.
    Try    Fails immediately              Fails immediately.
    Timed  Waits.  Fails after timeout.   Fails immediately if no sources, otherwise waits till timeout.
    </pre></div><h2><a class="anchor" id="peek">
Peek Functions</a></h2>
<p>The <a class="el" href="chan_8c.html#a1abcab692ce790b9e0842ab6162780e9">Chan_Peek()</a> functions behave very similarly to the <a class="el" href="chan_8c.html#acc5d7503399436e951fac0923371990e" title="Push or pop next item. May block the calling thread.">Chan_Next()</a> family. However, <a class="el" href="chan_8c.html#a1abcab692ce790b9e0842ab6162780e9">Chan_Peek()</a> does not alter the queue. The message at the end of the queue is copied into supplied buffer. The buffer may be resized to fit the message.</p>
<p>The <a class="el" href="chan_8c.html#a1abcab692ce790b9e0842ab6162780e9">Chan_Peek()</a> functions do not require a <a class="el" href="chan_8h.html#a7b5f296618b811f11b7fefa902ca400a">Chan</a> to be opened in any particular mode. However, the <a class="el" href="chan_8h.html#a7b5f296618b811f11b7fefa902ca400a">Chan</a> must be opened with <a class="el" href="chan_8c.html#a9be0713b51726eb1708bc00eb334edf4" title="does ref counting and access type">Chan_Open()</a>. The <a class="el" href="chan_8h.html#a18e6baae740254b6b2ce122063dbedc0a64a57a14a966780bff2b90968dd006cf">CHAN_PEEK</a> mode is recommended for readability.</p>
<h2><a class="anchor" id="mem">
Memory management</a></h2>
<p><a class="el" href="chan_8h.html#a7b5f296618b811f11b7fefa902ca400a">Chan</a> is a zero-copy queue. Instead of copying data, the queue operates on pointers. The pointers address heap allocated blocks of data that are, ideally, big enough for your messages. The block size is set by the <a class="el" href="chan_8c.html#a32df9018f0be4ff3a9839ba338c089b1">Chan_Alloc()</a> call. <a class="el" href="chan_8c.html#a7f59838d7bc706c99badb704caf78467">Chan_Resize()</a> can be used to change the size of the blocks, though it is only possible to <em>increase</em> the size.</p>
<p>When a buffer is swapped on to a queue via <a class="el" href="chan_8c.html#acc5d7503399436e951fac0923371990e" title="Push or pop next item. May block the calling thread.">Chan_Next()</a>, it may be resized so it is large enough to hold a block. It is recommended that <a class="el" href="chan_8c.html#a54ece3f41ff61f2b2f5e563028b44d73">Chan_Token_Buffer_Alloc()</a> is used to pre-allocate buffers that are to be swapped on to the queue. If nothing else, it might help you remember to free any blocks returned by <a class="el" href="chan_8c.html#acc5d7503399436e951fac0923371990e" title="Push or pop next item. May block the calling thread.">Chan_Next()</a>.</p>
<p>That said, it's definitely possible to do: </p>
<div class="fragment"><pre class="fragment">    { <span class="keywordtype">void</span> *data    = NULL;
      <span class="keywordtype">size_t</span> nbytes = 0;
      <a class="code" href="chan_8c.html#acc5d7503399436e951fac0923371990e" title="Push or pop next item. May block the calling thread.">Chan_Next</a>(q,&amp;data,&amp;nbytes);             <span class="comment">// q can have CHAN_READ or CHAN_WRITE mode</span>
      <span class="comment">// data now points to a buffer of size nbytes.</span>
      <span class="comment">// if Chan_Next failed, data might still be NULL.</span>
      <span class="keywordflow">if</span>(data) <a class="code" href="chan_8c.html#a9ff0178bfa0e25b95002b844d6794ce2">Chan_Token_Buffer_Free</a>(data);  <span class="comment">// remember to free the data!</span>
    }
</pre></div> </div>
<!--- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&nbsp;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&nbsp;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&nbsp;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&nbsp;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&nbsp;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&nbsp;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&nbsp;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&nbsp;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&nbsp;</span>Defines</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<hr class="footer"/><address style="text-align: right;"><small>Generated on Tue Mar 27 20:30:34 2012 for chan by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.6.3 </small></address>
</body>
</html>
